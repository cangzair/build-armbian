#!/bin/bash
#==============================================================================================
#
# This file is licensed under the terms of the GNU General Public
# License version 2. This program is licensed "as is" without any
# warranty of any kind, whether express or implied.
#
# 该脚本文件 只是编译 Armbian 的内核
# https://github.com/ophub/amlogic-s9xxx-armbian
#
# 仅支持在 Ubuntu-20.04-x86_64 系统上运行，为 Amlogic s9xxx 电视盒编译内核
# Copyright (C) 2021- https://github.com/unifreq
# Copyright (C) 2021- https://github.com/ophub/amlogic-s9xxx-armbian
#
# Command: sudo ./recompile -d
# 命令可选参数请参考源码仓库
#
#======================================= 功能列表 =======================================
#
# error_msg          : 显示错误信息
#
# init_var           : 初始化所有变量
# toolchain_check    : 检查并安装交叉编译工具链 (GCC, Clang, Armbian)
# query_version      : 查询最新内核版本
#
# get_kernel_source  : 获取内核源代码
# env_check          : 检查编译内核的环境
# compile_kernel     : 编译内核
# generate_uinitrd   : 进入 Chroot Armbian 系统 生成成 initrd.img 和 uInitrd
# packit_kernel      : 打包全部内核文件
# clean_tmp          : 清除临时文件
#
# loop_recompile     : 重复编译内核动作
#
#=============================== 设置 Make 环境变量 ===============================
#
# 文件的路径
make_path="${PWD}"
compile_path="${make_path}/compile-kernel"
kernel_path="${compile_path}/kernel"
config_path="${compile_path}/tools/config"
script_path="${compile_path}/tools/script"
armbian_path="${compile_path}/tools/armbian"
armbian_file="${armbian_path}/armbian.img"
out_kernel="${compile_path}/output"
chroot_path="${out_kernel}/chroot"
chroot_file="${chroot_path}/chroot_armbian.img"
arch_info="$(arch)"
toolchain_path="/usr/local/toolchain"
#
# 设置 [ -r ] 参数的默认值
# 当设置为 [ -r kernel.org ] 时，内核从官网 kernel.org 下载
kernel_org_repo="https://cdn.kernel.org/pub/linux/kernel/v5.x/"
# 设置下载 默认内核源 从 github.com 仓库下载
repo_owner="unifreq"
repo_branch="main"
build_kernel=("5.4.191" "5.10.113" "5.15.37")
auto_kernel="true"
custom_name=""
#
# 交叉编译工具链下载，仅在 ubuntu-20.04 系统上运行
dev_repo="https://github.com/cangzair/Public/releases/download/Armbian_Build_Tool"
#
# Armbian 下载地址: https://github.com/ophub/amlogic-s9xxx-armbian/releases
armbian_rootfs_file="armbian_22.05.0_aml_s905d_bullseye_5.4.191.tar.xz"
#
# GCC 下载地址: https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/downloads
gcc_file="gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz"
#
# Clang 下载地址: https://github.com/llvm/llvm-project/releases
clang_file="clang+llvm-13.0.0-x86_64-linux-gnu-ubuntu-20.04.tar.xz"
#
# QEMU 虚拟机系统
qemu_binary_arm="qemu-arm-static"
qemu_binary_arm64="qemu-aarch64-static"
#
# 设置字体颜色
blue_font_prefix="\033[94m"
purple_font_prefix="\033[95m"
green_font_prefix="\033[92m"
yellow_font_prefix="\033[93m"
red_font_prefix="\033[91m"
font_color_suffix="\033[0m"
INFO="[${blue_font_prefix}INFO${font_color_suffix}]"
STEPS="[${purple_font_prefix}STEPS${font_color_suffix}]"
SUCCESS="[${green_font_prefix}SUCCESS${font_color_suffix}]"
WARNING="[${yellow_font_prefix}WARNING${font_color_suffix}]"
ERROR="[${red_font_prefix}ERROR${font_color_suffix}]"
#
#==============================================================================================

error_msg() {
    echo -e "${ERROR} ${1}"
    exit 1
}

init_var() {
    cd ${make_path}

    # 如果后面有[:]，则表示该选项需要一个参数值
    get_all_ver=$(getopt "dk:a:n:r:" "${@}")

    while [ -n "${1}" ]; do
        case "${1}" in
        -d | --default)
            : ${build_kernel:="${build_kernel}"}
            : ${auto_kernel:="${auto_kernel}"}
            : ${custom_name:="${custom_name}"}
            : ${repo_owner:="${repo_owner}"}
            ;;
        -k | --kernel)
            if [ -n "${2}" ]; then
                oldIFS=$IFS
                IFS=_
                build_kernel=(${2})
                IFS=$oldIFS
                shift
            else
                error_msg "-k 参数无效 [ ${2} ]!"
            fi
            ;;
        -a | --autoKernel)
            if [ -n "${2}" ]; then
                auto_kernel="${2}"
                shift
            else
                error_msg "-a 参数无效 [ ${2} ]!"
            fi
            ;;
        -n | --customName)
            if [ -n "${2}" ]; then
                custom_name="${2}"
                shift
            else
                error_msg "-n 参数无效 [ ${2} ]!"
            fi
            ;;
        -r | --repo)
            if [ -n "${2}" ]; then
                repo_owner="${2}"
                shift
            else
                error_msg "-r 参数无效 [ ${2} ]!"
            fi
            ;;
        *)
            error_msg "无效的选项 [ ${1} ]!"
            ;;
        esac
        shift
    done

    # 接收 [ -r ] 参数输入的值
    input_r_value="${repo_owner//https\:\/\/github\.com\//}"
    code_owner="$(echo "${input_r_value}" | awk -F '@' '{print $1}' | awk -F '/' '{print $1}')"
    code_repo="$(echo "${input_r_value}" | awk -F '@' '{print $1}' | awk -F '/' '{print $2}')"
    code_branch="$(echo "${input_r_value}" | awk -F '@' '{print $2}')"
    #
    [ -n "${code_owner}" ] || error_msg "The [ -r ] parameter is invalid."
    [ -n "${code_branch}" ] || code_branch="${repo_branch}"
}

toolchain_check() {
    cd ${make_path}
    echo -e "${STEPS} 检查交叉编译环境 ..."

    [ -d "${toolchain_path}" ] || mkdir -p ${toolchain_path}

    # 下载 gcc
    if [ ! -d "${toolchain_path}/${gcc_file//.tar.xz/}/bin" ]; then
        echo -e "${INFO} 下载 gcc [ ${gcc_file} ] ..."
        wget -c "${dev_repo}/${gcc_file}" -O "${toolchain_path}/${gcc_file}" >/dev/null 2>&1 && sync
        tar -xJf ${toolchain_path}/${gcc_file} -C ${toolchain_path} && sync
        rm -f ${toolchain_path}/${gcc_file} && sync
        [ -d "${toolchain_path}/${gcc_file//.tar.xz/}/bin" ] || error_msg "The gcc is not set!"
    fi

    # 下载 clang
    if [ ! -d "${toolchain_path}/${clang_file//.tar.xz/}/bin" ]; then
        echo -e "${INFO} 下载 clang [ ${clang_file} ] ..."
        wget -c "${dev_repo}/${clang_file}" -O "${toolchain_path}/${clang_file}" >/dev/null 2>&1 && sync
        tar -xJf ${toolchain_path}/${clang_file} -C ${toolchain_path} && sync
        rm -f ${toolchain_path}/${clang_file} && sync
        [ -d "${toolchain_path}/${clang_file//.tar.xz/}/bin" ] || error_msg "没有设置 clang !"
    fi

    # 下载 armbian
    if [ ! -f "${armbian_file}" ]; then
        echo -e "${INFO} 下载 Armbian [ ${armbian_rootfs_file} ] ..."
        rm -rf ${armbian_path} 2>/dev/null && mkdir -p ${armbian_path}
        wget -c "${dev_repo}/${armbian_rootfs_file}" -O "${armbian_path}/${armbian_rootfs_file}" >/dev/null 2>&1 && sync
        tar -xJf ${armbian_path}/${armbian_rootfs_file} -C ${armbian_path} && sync
        mv -f ${armbian_path}/*.img ${armbian_file} && sync
        rm -f ${armbian_path}/${armbian_rootfs_file} && sync
        [ -f "${armbian_file}" ] || error_msg "没有 Armbian 文件: [ ${armbian_file} ]"
    fi
}

query_version() {
    cd ${make_path}
    # Set empty array
    tmp_arr_kernels=()

    # 查询是否为最新内核
    i=1
    for KERNEL_VAR in ${build_kernel[*]}; do
        echo -e "${INFO} (${i}) 自动查询同系列最新内核版本 [ ${KERNEL_VAR} ]"
        MAIN_LINE_M=$(echo "${KERNEL_VAR}" | cut -d '.' -f1)
        MAIN_LINE_V=$(echo "${KERNEL_VAR}" | cut -d '.' -f2)
        MAIN_LINE_S=$(echo "${KERNEL_VAR}" | cut -d '.' -f3)
        MAIN_LINE="${MAIN_LINE_M}.${MAIN_LINE_V}"

        if [ "${code_owner}" == "kernel.org" ]; then
            latest_version=$(curl -s ${kernel_org_repo} | grep -oE linux-${MAIN_LINE}.[0-9]+.tar.xz | sort -rV | head -n 1 | grep -oE '[1-9].[0-9]{1,3}.[0-9]+')
            if [[ "$?" -eq "0" && ! -z "${latest_version}" ]]; then
                tmp_arr_kernels[${i}]="${latest_version}"
            else
                error_msg "查询内核版本失败 [ ${kernel_org_repo} ]"
            fi
            echo -e "${INFO} (${i}) [ ${tmp_arr_kernels[$i]} ] is kernel.org latest kernel. \n"
        else
            if [ -z "${code_repo}" ]; then linux_repo="linux-${MAIN_LINE}.y"; else linux_repo="${code_repo}"; fi
            github_kernel_repo="${code_owner}/${linux_repo}/${code_branch}"
            github_kernel_ver="https://raw.githubusercontent.com/${github_kernel_repo}/Makefile"
            latest_version="$(curl -s ${github_kernel_ver} | grep -oE "SUBLEVEL =.*" | head -n 1 | grep -oE '[0-9]{1,3}')"
            if [[ "$?" -eq "0" && ! -z "${latest_version}" ]]; then
                tmp_arr_kernels[${i}]="${MAIN_LINE}.${latest_version}"
            else
                error_msg "查询内核版本失败 [ github.com/${github_kernel_repo} ]"
            fi
            echo -e "${INFO} (${i}) [ ${tmp_arr_kernels[$i]} ] 是 github.com/${github_kernel_repo} 最新内核. \n"
        fi

        let i++
    done

    # 将内核阵列重置为最新的版本
    unset build_kernel
    build_kernel=${tmp_arr_kernels[*]}
}

get_kernel_source() {
    cd ${make_path}
    echo -e "${STEPS} 下载内核源码."
    [ -d "${kernel_path}" ] || mkdir -p ${kernel_path}
    if [ ! -d "${kernel_path}/${local_kernel_path}" ]; then
        if [ "${code_owner}" == "kernel.org" ]; then
            if [ -f "${kernel_path}/${local_kernel_path}.tar.xz" ]; then
                echo -e "${INFO} 解压本地文件 [ ${local_kernel_path}.tar.xz ]"
                cd ${kernel_path}
                tar -xJf ${local_kernel_path}.tar.xz
                [ "$?" -eq "0" ] || error_msg "[ ${local_kernel_path}.tar.xz ] 文件解压失败."
            else
                echo -e "${INFO} [ ${kernel_version} ] 内核加载 [ ${server_kernel_repo}${local_kernel_path}.tar.xz ]"
                wget -q -P ${kernel_path} ${server_kernel_repo}${local_kernel_path}.tar.xz && sync
                if [[ "$?" -eq "0" && -s "${kernel_path}/${local_kernel_path}.tar.xz" ]]; then
                    echo -e "${SUCCESS} 内核文件下载成功."
                    cd ${kernel_path}
                    tar -xJf ${local_kernel_path}.tar.xz && sync
                    [ -d "${local_kernel_path}" ] || error_msg "[ ${local_kernel_path}.tar.xz ] 文件解压失败."
                else
                    error_msg "内核文件下载失败!"
                fi
            fi
        else
            echo -e "${INFO} 开始获取 [ https://github.com/${server_kernel_repo} -b ${code_branch} ]"
            git clone --depth 1 https://github.com/${server_kernel_repo} -b ${code_branch} ${kernel_path}/${local_kernel_path}
            [ "$?" -eq "0" ] || error_msg "[ https://github.com/${server_kernel_repo} ] 获取失败."
        fi
    elif [ "${code_owner}" != "kernel.org" ]; then
        # 获取本地内核版本
        local_makefile="${kernel_path}/${local_kernel_path}/Makefile"
        local_makefile_version="$(cat ${local_makefile} | grep -oE "VERSION =.*" | head -n 1 | grep -oE '[0-9]{1,3}')"
        local_makefile_patchlevel="$(cat ${local_makefile} | grep -oE "PATCHLEVEL =.*" | head -n 1 | grep -oE '[0-9]{1,3}')"
        local_makefile_sublevel="$(cat ${local_makefile} | grep -oE "SUBLEVEL =.*" | head -n 1 | grep -oE '[0-9]{1,3}')"

        # 本地版本和服务器版本对比
        if [[ "${auto_kernel}" == "true" && "${kernel_sub}" -gt "${local_makefile_sublevel}" ]]; then
            # 获取最新源代码
            cd ${kernel_path}/${local_kernel_path}
            git checkout ${code_branch} && git reset --hard origin/${code_branch} && git pull && sync
            unset kernel_version
            kernel_version="${local_makefile_version}.${local_makefile_patchlevel}.${kernel_sub}"
            echo -e "${INFO} 同步上游源码，编译的内核版本 [ ${kernel_version} ]."
        else
            # 本地内核版本
            unset kernel_version
            kernel_version="${local_makefile_version}.${local_makefile_patchlevel}.${local_makefile_sublevel}"
            echo -e "${INFO} 使用本地源码，编译的内核版本 [ ${kernel_version} ]."
        fi
    fi
    sync
}

env_check() {
    cd ${make_path}
    echo -e "${STEPS} 检查本地编译环境."

    # 获取编译的内核版本
    kernel_outname="${kernel_version}${custom_name}"
    echo -e "${INFO} 编译的内核版本 [ ${kernel_outname} ]. \n"

    # 创建临时目录
    rm -rf ${out_kernel}/{chroot/,boot/,dtb/,modules/,header/,${kernel_version}/} 2>/dev/null && sync
    mkdir -p ${out_kernel}/{chroot/{root/boot/,},boot/,dtb/{allwinner/,amlogic/,rockchip/},modules/,header/,${kernel_version}/} && sync
}

compile_kernel() {
    cd ${kernel_path}/${local_kernel_path}
    echo -e "${STEPS} 交叉编译参数."
    path_ubuntu2004="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin"
    path_clang="${toolchain_path}/${clang_file//.tar.xz/}/bin:${path_ubuntu2004}"
    export ARCH="arm64"
    export LOCALVERSION="${custom_name}"
    export PATH=${path_clang}
    export CROSS_COMPILE=${toolchain_path}/${gcc_file//.tar.xz/}/bin/aarch64-none-linux-gnu-
    export CC=${toolchain_path}/${clang_file//.tar.xz/}/bin/clang
    export LD=${toolchain_path}/${clang_file//.tar.xz/}/bin/ld.lld
    sed -i '/^PATH=/d' ~/.bashrc 2>/dev/null && sync
    echo "PATH=${path_clang}" >>~/.bashrc && sync
    source ~/.bashrc
    sed -i '/^PATH=/d' /etc/profile 2>/dev/null && sync
    echo "PATH=${path_clang}" >>/etc/profile && sync
    source /etc/profile

    # 变量
    echo -e "${INFO} ARCH: [ ${ARCH} ]"
    echo -e "${INFO} LOCALVERSION: [ ${LOCALVERSION} ]"
    echo -e "${INFO} PATH: [ ${PATH} ]"
    echo -e "${INFO} CROSS_COMPILE: [ ${CROSS_COMPILE} ]"
    echo -e "${INFO} CC: [ ${CC} ]"
    echo -e "${INFO} LD: [ ${LD} ]"
    # 默认编译命令
    MAKE_SET_STRING=" ARCH=${ARCH} CROSS_COMPILE=${CROSS_COMPILE} CC=${CC} LD=${LD} LLVM=1 LLVM_IAS=1 LOCALVERSION=${LOCALVERSION} "

    if [ ! -f ".config" ]; then
        # 复制内核配置文件
        echo -e "${INFO} 复制 .config 内核配置文件到 ${local_kernel_path}"
        config_demo=$(ls ${config_path}/config-${kernel_verpatch}* 2>/dev/null | sort -rV | head -n 1)
        config_demo_file=${config_demo##*/}
        [ -z "${config_demo_file}" ] && error_msg "Missing [ config-${kernel_verpatch}* ] template!"
        echo -e "${INFO} CONFIG_DEMO: [ ${config_path}/${config_demo_file} ]"
        cp -f ${config_path}/${config_demo_file} .config && sync
    else
        echo -e "${INFO} 使用当前目录下的 .config 内核配置文件."
    fi
    #
    sed -i "s|CONFIG_LOCALVERSION=.*|CONFIG_LOCALVERSION=\"\"|" .config
    sync

    # 启用/禁用 Linux 内核 Clang LTO
    kernel_x=$(echo "${kernel_version}" | cut -d '.' -f1)
    kernel_y=$(echo "${kernel_version}" | cut -d '.' -f2)
    if [[ "${kernel_x}" -ge "6" ]] || [[ "${kernel_x}" -eq "5" && "${kernel_y}" -ge "12" ]]; then
        scripts/config -e LTO_CLANG_THIN
    else
        scripts/config -d LTO_CLANG_THIN
    fi

    # 编译内核
    echo -e "${STEPS} 开始编译内核 请耐心等待 [ ${local_kernel_path} ]..."
    PROCESS="$(cat /proc/cpuinfo | grep "processor" | wc -l)"
    [ -z ${PROCESS} ] && PROCESS="1" && echo "PROCESS: 1"
    make ${MAKE_SET_STRING} Image modules dtbs -j${PROCESS}
    [ $? -eq 0 ] && echo -e "${SUCCESS} 内核编译成功."

    # Install modules
    echo -e "${STEPS} 安装内核模块 ..."
    make ${MAKE_SET_STRING} INSTALL_MOD_PATH=${out_kernel}/modules modules_install
    [ $? -eq 0 ] && echo -e "${SUCCESS} 内核模块安装成功."

    # Install headers
    echo -e "${STEPS} 安装 headers ..."
    make ${MAKE_SET_STRING} INSTALL_HDR_PATH=${out_kernel}/header headers_install
    [ $? -eq 0 ] && echo -e "${SUCCESS} headers 安装成功."
}

generate_uinitrd() {
    cd ${make_path}
    echo -e "${STEPS} 创建 Chroot..."

    cp -f ${armbian_file} ${chroot_file} && sync

    # 挂载 Armbian 系统
    tag_rootfs=${chroot_path}/root

    loop_armbian=$(losetup -P -f --show "${chroot_file}")
    [ ${loop_armbian} ] || error_msg "losetup ${chroot_file} failed."

    if ! mount ${loop_armbian}p2 ${tag_rootfs}; then
        error_msg "mount ${loop_armbian}p2 failed!"
    fi
    if ! mount ${loop_armbian}p1 ${tag_rootfs}/boot; then
        error_msg "mount ${loop_armbian}p1 failed!"
    fi

    # 将boot相关文件 复制到 Armbian 系统中
    rm -f ${tag_rootfs}/boot/{config-*,initrd.img-*,System.map-*,uInitrd-*,vmlinuz-*,uInitrd,zImage} 2>/dev/null && sync
    #
    cp -f ${kernel_path}/${local_kernel_path}/System.map ${tag_rootfs}/boot/System.map-${kernel_outname}
    cp -f ${kernel_path}/${local_kernel_path}/.config ${tag_rootfs}/boot/config-${kernel_outname}
    cp -f ${kernel_path}/${local_kernel_path}/arch/arm64/boot/Image ${tag_rootfs}/boot/vmlinuz-${kernel_outname}
    sync

    rm -rf ${tag_rootfs}/usr/lib/modules/* 2>/dev/null && sync
    cp -rf ${out_kernel}/modules/lib/modules/${kernel_outname} ${tag_rootfs}/usr/lib/modules && sync

    # 压缩: [ gzip | bzip2 | lz4 | lzma | lzop | xz | zstd ]
    compress_initrd_file="${tag_rootfs}/etc/initramfs-tools/initramfs.conf"
    sed -i "/^COMPRESS=/d" ${compress_initrd_file} && sync
    echo "COMPRESS=gzip" >>${compress_initrd_file} && sync

    [ -f "/usr/bin/${qemu_binary_arm}" ] && cp -f /usr/bin/${qemu_binary_arm} ${tag_rootfs}/usr/bin/ && sync
    [ -f "/usr/bin/${qemu_binary_arm64}" ] && cp -f /usr/bin/${qemu_binary_arm64} ${tag_rootfs}/usr/bin/ && sync

    cp -f ${script_path}/generate_uinitrd.sh ${tag_rootfs}/root 2>/dev/null && sync
    chmod +x ${tag_rootfs}/root/generate_uinitrd.sh 2>/dev/null

    # 进入 Armbian系统 生成 /boot/uInitrd-${kernel_outname} 文件
    echo -e "${INFO} 进入 Chroot Armbian 系统..."
    chroot ${tag_rootfs} /bin/bash -c "/root/generate_uinitrd.sh ${kernel_outname}"
    [[ $? -ne 0 || ! -f "${tag_rootfs}"/boot/uInitrd-${kernel_outname} ]] && error_msg "创建 uInitrd-${kernel_outname} 文件失败."

    cd ${make_path}
    # 将生成的 uInitrd文件 复制到当前系统
    echo -e "${INFO} 复制生成的文件 [ ${tag_rootfs}/boot ]"
    cp -f ${tag_rootfs}/boot/*${kernel_outname} ${out_kernel}/boot && sync

    # 卸载 Armbian 系统
    umount ${tag_rootfs}/boot 2>/dev/null
    umount ${tag_rootfs} 2>/dev/null
    losetup -D 2>/dev/null
}

packit_kernel() {
    # 打包内核6个文件
    echo -e "${STEPS} 即将打包 [ ${kernel_outname} ] 内核包..."

    cd ${out_kernel}/boot
    chmod +x *
    tar -czf boot-${kernel_outname}.tar.gz * && sync
    mv -f *.tar.gz ${out_kernel}/${kernel_version} && sync
    echo -e "${SUCCESS} 这个 [ boot-${kernel_outname}.tar.gz ] 文件已打包."

    cd ${out_kernel}/dtb/allwinner
    cp -f ${kernel_path}/${local_kernel_path}/arch/arm64/boot/dts/allwinner/*.dtb . && chmod +x * && sync
    tar -czf dtb-allwinner-${kernel_outname}.tar.gz * && sync
    mv -f *.tar.gz ${out_kernel}/${kernel_version} && sync
    echo -e "${SUCCESS} 这个 [ dtb-allwinner-${kernel_outname}.tar.gz ] 文件已打包."

    cd ${out_kernel}/dtb/amlogic
    cp -f ${kernel_path}/${local_kernel_path}/arch/arm64/boot/dts/amlogic/*.dtb . && chmod +x * && sync
    tar -czf dtb-amlogic-${kernel_outname}.tar.gz * && sync
    mv -f *.tar.gz ${out_kernel}/${kernel_version} && sync
    echo -e "${SUCCESS} 这个 [ dtb-amlogic-${kernel_outname}.tar.gz ] 文件已打包."

    cd ${out_kernel}/dtb/rockchip
    cp -f ${kernel_path}/${local_kernel_path}/arch/arm64/boot/dts/rockchip/*.dtb . && chmod +x * && sync
    tar -czf dtb-rockchip-${kernel_outname}.tar.gz * && sync
    mv -f *.tar.gz ${out_kernel}/${kernel_version} && sync
    echo -e "${SUCCESS} 这个 [ dtb-rockchip-${kernel_outname}.tar.gz ] 文件已打包."

    cd ${out_kernel}/modules/lib/modules
    tar -czf modules-${kernel_outname}.tar.gz * && sync
    mv -f *.tar.gz ${out_kernel}/${kernel_version} && sync
    echo -e "${SUCCESS} 这个 [ modules-${kernel_outname}.tar.gz ] 文件已打包."

    cd ${out_kernel}/header
    tar -czf header-${kernel_outname}.tar.gz * && sync
    mv -f *.tar.gz ${out_kernel}/${kernel_version} && sync
    echo -e "${SUCCESS} 这个 [ header-${kernel_outname}.tar.gz ] 文件已打包."

    cd ${out_kernel}
    tar -czf ${kernel_version}.tar.gz ${kernel_version} && sync

    echo -e "${INFO} 内核文件存储在 [ ${out_kernel} ]."
}

clean_tmp() {
    cd ${make_path}
    echo -e "${STEPS} 清理临时空间."

    rm -rf ${out_kernel}/{chroot/,boot/,dtb/,modules/,header/,${kernel_version}/} 2>/dev/null && sync

    update-grub 2>/dev/null
    echo -e "${SUCCESS} 临时空间清理完成."

    sync
    echo -e "${SUCCESS} 所有操作均已成功完成."
}

loop_recompile() {
    cd ${make_path}

    j=1
    for k in ${build_kernel[*]}; do
        # kernel_version, such as [ 5.10.100 ]
        kernel_version="${k}"
        # kernel_verpatch, such as [ 5.10 ]
        kernel_verpatch="$(echo ${kernel_version} | awk -F '.' '{print $1"."$2}')"
        # kernel_sub, such as [ 100 ]
        kernel_sub="$(echo ${kernel_version} | awk -F '.' '{print $3}')"

        # The loop variable assignment
        if [ "${code_owner}" == "kernel.org" ]; then
            server_kernel_repo="${kernel_org_repo}"
            local_kernel_path="linux-${kernel_version}"
        elif [ -z "${code_repo}" ]; then
            server_kernel_repo="${code_owner}/linux-${kernel_verpatch}.y"
            local_kernel_path="linux-${kernel_verpatch}.y"
        else
            server_kernel_repo="${code_owner}/${code_repo}"
            local_kernel_path="${code_repo}-${code_branch}"
        fi

        # Execute the following functions in sequence
        get_kernel_source
        env_check
        compile_kernel
        generate_uinitrd
        packit_kernel
        clean_tmp

        let j++
    done
}

# Show welcome message
echo -e "Welcome to compile kernel! \n"
[ $(id -u) = 0 ] || error_msg "Please run this script as root: [ sudo ./$0 ]"
[[ ${arch_info} == "x86_64" ]] || error_msg "Please run this script on ubuntu-20.04"
# Show server start information
echo -e "服务器CPU配置信息: \n$(cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c) \n"
echo -e "服务器内存使用情况: \n$(free -h) \n"
echo -e "服务器空间使用情况: \n$(df -hT ${PWD}) \n"
#
# Initialize variables and download the kernel source code
init_var "${@}"
[[ "${auto_kernel}" == "true" ]] && query_version
echo -e "内核源码来自: [ ${code_owner} ]"
echo -e "即将编译的内核: [ $(echo ${build_kernel[*]} | tr "\n" " ") ] \n"
# Check the toolchain and loop to compile the kernel
toolchain_check
loop_recompile
#
# Show server end information
echo -e "${INFO} 编译完成后的服务器空间使用情况: \n$(df -hT ${PWD}) \n"
# All process completed
wait
